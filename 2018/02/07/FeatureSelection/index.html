
<!DOCTYPE html>
<html lang="zh-CN">


<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="theme-color" content="#202020" />
  <meta http-equiv="x-ua-compatible" content="ie=edge">

  
  <meta name="keywords" content="翻译,特征选择," />
  

  
  <meta name="description" content="特征选择引言" />
  

  <link rel="icon" type="image/x-icon" href="/img/logo.png">
  <title>
    特征选择引言 [ 仁梓小舍 ]
  </title>
  
  <!-- stylesheets list from config.yml -->
  
  <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
  
  <link rel="stylesheet" href="/css/microb.css">
  
  
<link rel="stylesheet" href="/css/prism.css" type="text/css"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="home-menu pure-menu pure-menu-horizontal pure-menu-fixed">
  <ul class="pure-menu-list float-r clearfix">
    
    <li class="pure-menu-item toc-menu">
      <a id="menu-main-post" class="pure-menu-link" href="javascript:;">
        <img class="menu-icon" src="/img/logo.png" alt="MENU">
      </a>
    </li>
    
  </ul>
  <a class="pure-menu-heading" href="/">
    <h1 class="title">
      仁梓小舍
    </h1>
    <!-- <span>null</span> -->
  </a>
  <!-- 
  <img class="logo" id="logo" src="/logo.png" alt="logo">
   -->
</nav>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <article class="post" id="post">
  <header class="post-header text-center">
    <h1 class="title">
      特征选择引言
    </h1>
    
    <time class="time" datetime="2018-02-07T02:35:41.000Z">
      2018-02-07
    </time>
    
    <hr>
  </header>
  <div class="post-content">
    <p>您应该采纳哪种特征去创建一个可预测的模型呢？</p>
<p>这是一个难题，可能需要您对问题有深入的了解。</p>
<p>自动筛选您的数据中最具价值和最相关的特征是可能的，这个过程被称为是特征选择。</p>
<p>在这篇文章中，您会了解到特征选择（<code>feature selection</code>），下一次您可以使用同种类型的方法和一个有制可循的清单，以供您在需要选择机器学习模型特征时使用。</p>
<p><img src="https://3qeqpr26caki16dnhd19sv6by6v-wpengine.netdna-ssl.com/wp-content/uploads/2014/10/feature-selection.jpg" alt=""></p>
<p>特征选择引言</p>
<p>由 <a href="https://www.flickr.com/photos/31031835@N08/6498604953" target="_blank" rel="external"><code>John Tann</code></a>拍摄，保留部分权利</p>
<h2 id="什么是特征选择"><a href="#什么是特征选择" class="headerlink" title="什么是特征选择"></a>什么是特征选择</h2><p>特征选择又被称为变量选择（<code>variable selection</code>）或者属性选择（<code>attribute selection</code>）。</p>
<p>这是一种自动选择数据（如表格数据中的列）的方式，它自动选择属性，属性中会包括与您正在处理的预测建模问题最相关的数据。</p>
<blockquote>
<p>特征选择…是选择用于构建相关特征子集模型的过程</p>
</blockquote>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Feature_selection" target="_blank" rel="external">特征选择</a>，维基百科条目。</li>
</ul>
<p>特征选择不同于维数约简（<code>dimensionality reduction</code>）。这两种方法都试图减少数据集中属性的数量，但维数约简通过创建新的属性集合来实现，特征选择则是依靠不改变数据的方式，去包含和排除数据中存在的属性来实现。</p>
<p>降维方法的例子包括主成分分析（<code>Component Analysis</code>），奇异值分解（<code>Singular Value Decomposition</code>）和 <code>Sammon</code> 映射 （<code>Sammon’s Mapping.</code>）。</p>
<blockquote>
<p>特征选择是有用的，但它主要作为一个过滤器，消除除了您现有的特征之外没有用的特征。</p>
</blockquote>
<ul>
<li>罗伯特·诺伊豪斯（Robert Neuhaus）回答“ <a href="http://www.quora.com/How-valuable-do-you-think-feature-selection-is-in-machine-learning-Which-do-you-think-improves-accuracy-more-feature-selection-or-feature-engineering" target="_blank" rel="external">您认为机器学习中的特征选择有多宝贵？</a>”</li>
</ul>
<h2 id="特征选择解决的问题"><a href="#特征选择解决的问题" class="headerlink" title="特征选择解决的问题"></a>特征选择解决的问题</h2><p>特征选择方法帮助您完成任务，创建精确的预测模型。在需要更少的数据的同时，他们通过特征选择能够提供不错甚至更棒的准确性。</p>
<p>特征选择方法可以用来识别和去除数据，这种数据中包含无用，不相关和冗余的属性，他们会造成预测失真或者降低模型的实际的准确性。</p>
<p>更少的属性是可取的，因为它降低了模型的复杂性，更简单的模型更容易理解和解释。</p>
<blockquote>
<p>变量选择的目标有三个方面：提高预测变量的预测性能，提供更快速，更具成本效益的预测变量，并更好地理解生成数据的底层运行。</p>
</blockquote>
<ul>
<li>Guyon和Elisseeff的“ <a href="http://jmlr.csail.mit.edu/papers/volume3/guyon03a/guyon03a.pdf" target="_blank" rel="external">变量和特征选择引言</a> ”（PDF）</li>
</ul>
<h2 id="特征选择算法"><a href="#特征选择算法" class="headerlink" title="特征选择算法"></a>特征选择算法</h2><p>有三大类特征选择算法：过滤方法（<code>filter methods</code>），包装器方法（<code>wrapper methods</code>）和嵌入方法（<code>embedded methods.</code>）。</p>
<h3 id="过滤方法"><a href="#过滤方法" class="headerlink" title="过滤方法"></a>过滤方法</h3><p>过滤器特征选择方法应用统计度量来为每个特征分配评分，这些特征按照得分排序，选择保留或是从数据集中删除，这些方法通常是单变量的，并且独立地考虑这个特征或者考虑因变量。</p>
<p>例如，过滤方法包括Chi平方检验（<code>Chi squared test</code>），信息增益（<code>information gain</code>）和相关系数分数（<code>correlation coefficient scores</code>）。</p>
<h3 id="包装器方法"><a href="#包装器方法" class="headerlink" title="包装器方法"></a>包装器方法</h3><p>包装器方法选择一组特征值来协助检索问题，在这些特性中，不同的组合被准备、评估并与其他组合进行比较。通过模型的准确性分配一个分数，建立评估功能组合的预测模型。</p>
<p>搜索过程可能是有条不紊的，如最佳搜索（<code>best-first search</code>），它可以是随机的，如随机爬山算法（<code>hill-climbing algorithm</code>），也可以使用启发式，如向前和向后遍历来添加和删除特征。</p>
<p>包装器方法是递归特征消除算法的一个例子。</p>
<h3 id="嵌入式方法"><a href="#嵌入式方法" class="headerlink" title="嵌入式方法"></a>嵌入式方法</h3><p>嵌入的方法可以了解在模型创建时，哪些特性对模型的精确性做出了最好的贡献。最常见的嵌入式特征选择方法是正则化方法（<code>regularization methods</code>）。</p>
<p>正则化方法也被称为惩罚方法（<code>penalization methods</code>），其将额外的约束引入到优化预测算法（例如回归算法（<code>regression algorithm</code>））中，将模型约束为较低的复杂性（较少的系数）。</p>
<p>正则化算法的例子是<code>LASSO</code>（<code>Least absolute shrinkage and selection operator</code>），弹性网络（<code>Elastic Net</code>）和岭回归（<code>Ridge regression</code>）。</p>
<h2 id="功能选择教程和配方"><a href="#功能选择教程和配方" class="headerlink" title="功能选择教程和配方"></a>功能选择教程和配方</h2><p>我们已经在这个博客上看到了很多功能选择的例子。</p>
<ul>
<li><strong>Weka</strong>：有关如何使用 <code>Weka</code> 执行特征选择的教程，请参阅“ <a href="http://machinelearningmastery.com/feature-selection-to-improve-accuracy-and-decrease-training-time/" target="_blank" rel="external">特征选择以提高准确性和减少训练时间</a> ”。</li>
<li><strong>Scikit-Learn</strong>：有关使用<code>Python</code> 中的 <code>scikit-learn</code> 递归消除的方法，请参阅“ <a href="http://machinelearningmastery.com/feature-selection-in-python-with-scikit-learn/" target="_blank" rel="external">使用Scikit-Learn在Python中进行功能选择</a> ”。</li>
<li><strong>R</strong>：有关使用<code>Caret R</code>软件包进行递归功能消除的方法，请参阅<a href="http://machinelearningmastery.com/feature-selection-with-the-caret-r-package/" target="_blank" rel="external">使用Caret R软件包进行功能选择</a> ”</li>
</ul>
<h2 id="选择功能时的陷阱"><a href="#选择功能时的陷阱" class="headerlink" title="选择功能时的陷阱"></a>选择功能时的陷阱</h2><p>特征选择是应用机器学习过程的另一个关键部分，如模型选择，您不能一劳永逸。</p>
<p>将特征选择作为模型选择过程的一部分是很重要的。如果您不这样做，您可能会无意中将偏差引入您的模型中，导致过度拟合。</p>
<blockquote>
<p>…应该在不同的数据集上进行特征选择，而不是在训练您的预测模型上进行特征选择……不这样做的效果是您会过度训练您的训练数据。</p>
</blockquote>
<ul>
<li>Ben Allison在回答“ <a href="http://stats.stackexchange.com/questions/40576/is-using-the-same-data-for-feature-selection-and-cross-validation-biased-or-not" target="_blank" rel="external">使用相同的数据进行特征选择和交叉验证是否存在偏差？</a>”</li>
</ul>
<p>例如，当您使用交叉验证等准确性估计方法时，必须在内部循环中包含特征选择。这意味着在模型训练之前，在准备好的文件夹上执行特征选择。一个错误的做法是首先执行特征选择，然后准备数据，再对所选特征执行模型选择和训练。</p>
<blockquote>
<p>如果我们采用适当的程序，并在每一个文件夹中进行特征选择，那么在文件夹中所使用的特征选择中就不再有任何关于这些特征的信息。</p>
</blockquote>
<ul>
<li>Dikran Marsupial回答“ <a href="http://stats.stackexchange.com/questions/2306/feature-selection-for-final-model-when-performing-cross-validation-in-machine" target="_blank" rel="external">在机器学习中执行交叉验证时，最终模型的特性选择</a> ”</li>
</ul>
<p>原因是，选择这些特性的决策是在整个训练集上做出的，而这些决定又被传递到模型上。这可能会生成一种模型，该模型被选中的特性被增强，而不是通过其他模型进行反馈的，以获得更好的结果，所以实际上它是有偏差的结果。</p>
<blockquote>
<p>如果您对所有数据执行特征选择，然后进行交叉验证，那么交叉验证程序的每个文件夹中的测试数据也用于选择特征，这就是性能分析的偏差。</p>
</blockquote>
<ul>
<li>Dikran Marsupial回答“ <a href="http://stats.stackexchange.com/questions/27750/feature-selection-and-cross-validation" target="_blank" rel="external">特征选择和交叉验证</a> ”</li>
</ul>
<h2 id="功能选择清单"><a href="#功能选择清单" class="headerlink" title="功能选择清单"></a>功能选择清单</h2><p>“ <a href="http://jmlr.csail.mit.edu/papers/volume3/guyon03a/guyon03a.pdf" target="_blank" rel="external">变量和特征选择介绍</a> ”（PDF）的作者Isabelle Guyon和Andre Elisseeff 提供了一个极好的清单，您可以在下次需要为您预测建模问题选择特征数据时使用。</p>
<p>我在这里展示了部分清单的内容：</p>
<ol>
<li><strong>您有该领域知识吗？</strong>如果是的话，构建一组更好的临时“特性”。</li>
<li><strong>您的功能相称吗？</strong>如果不是，请考虑使其正常化。</li>
<li><strong>你怀疑特征的相互依存吗?</strong>如果是，通过构造连接特性或特性的产品来扩展您的特性，就像您的计算机资源允许的那样。</li>
<li><strong>您是否需要删除输入变量（例如，成本，速度或数据理解的原因）？</strong>如果没有，构造析取特征或特征的加权和。</li>
<li><strong>您是否需要单独评估特性(例如，了解它们对系统的影响，或者因为它们的数量太大，您需要进行第一次筛选)？</strong>如果是，则使用可变排序方法; 否则，无论如何，要获得基准的结果。</li>
<li><strong>您需要预测吗？</strong>如果否，停止</li>
<li><strong>您怀疑您的数据是“脏的”（有几个无意义的输入模式和/或噪声输出或错误的类标签）？</strong>如果是，则使用在步骤5中获得的排名最高的变量作为表示来检测异常值示例，检查和/或丢弃它们。</li>
<li><strong>您知道先做什么吗？</strong>如果没有，使用线性预测器。使用“探针”方法的正向选择方法作为停止标准，或者使用0-norm嵌入式方法进行比较，按照步骤5的排序，使用增加的特征子集构造一个相同性质的预测因子序列。您是否可以匹配或改进一个较小的子集的性能?如果是，可以尝试使用该子集的非线性预测器。</li>
<li><strong>您有新的想法，时间，计算资源和足够的例子吗？</strong>如果是的话，比较几种特征选择方法，包括您的新想法，相关系数，后向选择和嵌入方法。使用线性和非线性预测变量。选择最佳的模型选择方法</li>
<li><strong>您想要一个稳定的解决方案（以提高性能和/或理解）？</strong>如果是，请对数据进行子采样，并对几个“bootstrap”重新进行分析。</li>
</ol>
<h2 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h2><p>在特定平台上选择功能需要帮助吗？以下是一些可以帮助您快速入门的教程：</p>
<ul>
<li><a href="http://machinelearningmastery.com/perform-feature-selection-machine-learning-data-weka/" target="_blank" rel="external">如何在Weka中执行特征选择</a>（无代码）</li>
<li><a href="http://machinelearningmastery.com/feature-selection-machine-learning-python/" target="_blank" rel="external">如何使用scikit-learn在Python中执行特征选择</a></li>
<li><a href="http://machinelearningmastery.com/feature-selection-with-the-caret-r-package/" target="_blank" rel="external">如何使用插入符号在R中执行特征选择</a></li>
</ul>
<p>为了更深入地讨论这个话题，您可以选择一个关于这个话题的专业书籍，比如下面的任何一个：</p>
<ul>
<li><a href="http://www.amazon.com/dp/079238198X?tag=inspiredalgor-20" target="_blank" rel="external">知识发现和数据挖掘的特征选择</a></li>
<li><a href="http://www.amazon.com/dp/1584888784?tag=inspiredalgor-20" target="_blank" rel="external">特征选择的计算方法</a></li>
<li><a href="http://www.amazon.com/dp/0470229756?tag=inspiredalgor-20" target="_blank" rel="external">计算智能和特征选择：粗糙和模糊方法</a></li>
<li><a href="http://www.amazon.com/dp/3540341374?tag=inspiredalgor-20" target="_blank" rel="external">子空间，潜在结构和特征选择：统计和优化展望研讨会</a></li>
<li><a href="http://www.amazon.com/dp/0792381963?tag=inspiredalgor-20" target="_blank" rel="external">特征提取，构建和选择：数据挖掘的视角</a></li>
</ul>
<p>特征选择是特征工程的一个子课题。您可能想在帖子中深入研究特征工程：</p>
<p>您可能想在帖子中深入了解功能工程：</p>
<ul>
<li><a href="http://machinelearningmastery.com/discover-feature-engineering-how-to-engineer-features-and-how-to-get-good-at-it/" target="_blank" rel="external">发现特色工程，如何设计特色和如何做好它</a></li>
</ul>


    <!-- 显示photos -->
    

  </div>
  <div class="post-tags">
    <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/特征选择/">特征选择</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>
  </div>
</article>
  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <a href="/2018/02/03/PiplinesWithPlatform/" rel="next" title="Building Complex Data Pipelines with Unified Analytics Platform">
            <span>〈 </span> Building Complex Data Pipelines with Unified Analytics Platform
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
        
          <a href="/2018/12/02/SPRING-MVC-HLB/" rel="prev" title="【技术向】 看透 Spring MVC：源代码分析与实践 -- 持续更新">
            【技术向】 看透 Spring MVC：源代码分析与实践 -- 持续更新 <span>〉</span>
          </a>
        
      </div>
    </div>
  


  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是特征选择"><span class="toc-text">什么是特征选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特征选择解决的问题"><span class="toc-text">特征选择解决的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特征选择算法"><span class="toc-text">特征选择算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#过滤方法"><span class="toc-text">过滤方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#包装器方法"><span class="toc-text">包装器方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌入式方法"><span class="toc-text">嵌入式方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#功能选择教程和配方"><span class="toc-text">功能选择教程和配方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选择功能时的陷阱"><span class="toc-text">选择功能时的陷阱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#功能选择清单"><span class="toc-text">功能选择清单</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进一步阅读"><span class="toc-text">进一步阅读</span></a></li></ol>
  </div>


    </div>

    

  </div>

  <footer class="footer text-center">
    <div id="bottom-inner">
      
        <a href="http://hexo.io" target="_blank" class="footer-link">Hexo</a>
      
        <a href="https://github.com/microacup/hexo-theme-micorb" target="_blank" class="footer-link">Theme microb</a>
      
    </div>
  </footer>
  

<!-- <script>
  var titleTime,originTitle=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="[闷声发大财中...] "+originTitle,clearTimeout(titleTime)):(document.title="[+1s] "+originTitle,titleTime=setTimeout(function(){document.title=originTitle},2e3))});
</script> -->

<script>
  (function (window, document) {
    window.requestAnimationFrame = (function () {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function (callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();

    function init() {
      addMenuEvent();
    }
    init();

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        menu.title = toc ? '目录' : '回到顶部';
        menu.onclick = function () {
          if (toc) {
            if (toc.style.display == 'block') {
              toc.style.display = 'none';
            } else {
              toc.style.display = 'block';
            }
          } else {
            returnTop();
          }
        };
      }
    }

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

  })(window, document);
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


  



</body>
</html>
